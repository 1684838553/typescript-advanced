### 1. 泛型类定义 + 格式

1. 泛型是一种`参数化`数据类型,特点

   - 定义时不确定使用时必须明确成某种具体的数据类型【泛型的宽泛】

   - 编译期间进行数据类型安全检查的数据类型【泛型的严谨】

     **注意：**

   1. `类型安全检查发生在编译期间`

   2. 泛型时参数化数据类型，使用时明确化后的数据类型就是参数的值

2. 泛型类的格式

   ```typescript
   // 泛型形参类型两种表示：
   // 1. A-Z 任何一个字母 2. 语义化单词

   class 类名<泛型形参类型> {}

   class ArrayList<T> {
     array: Array<T>;
     add(data: T) {}
   }

   // 使用时，不传泛型类型，默认值是any
   let arrayList = new ArrayList<number>();

   // T 相当于 any
   let arrayList = new ArrayList();
   ```

### 2. object 为什么不能替代类上的泛型

1. `编译期间 object 无法进行泛型安全检查，而泛型在编译期间可以进行类型安全检查`

   object 接受也只能接受所有的 object 类型的变量，比如有 Customer、Student、Dog 类的实例都是对象类型，或者自己定义的对象，都可以传递给 object 类型的方法参数或属性， 但如果我们只希望添加 Customer 类的对象，当添加其他类的对象必须出现编译错误，但是 object 无法做到，就只能用泛型了。

2. `object 类型数据无法接受非 object 类型的变量，只能接受 object 类型的变量，泛型能轻松做到`

   正因为 object 接受也只能接受所有的 object 类型的变量，那么如果有一个集合类[数组封装类]有一个 add 方法，允许每次添加指定类型的变量到 add 方法的参数，比如：我们第一轮的希望添加 10 次字符串类型的变量，第二轮的希望添加 10 次整数类型变量，第三轮的希望添加 10 次顾客类型的变量，泛型轻松做到。object 类型数据无法接受任意非 object 类型的变量，object 只能接受所有的 object 类型的变量。

3. `object 类型数据获取属性和方法时无法自动提示`

### 3. any 为什么不能替代类上的泛型

1. `编译期间 object 无法进行泛型安全检查，而泛型在编译期间可以进行类型安全检查`

2. `any 扩大数据类型的属性后没有编译错误导致潜在风险，而泛型却有效的避免了此类问题发生`

3. `any 类型数据获取属性和方法时无法自动提示`
