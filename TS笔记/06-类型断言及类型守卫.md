## 类型断言、转换

`类型断言：`把两种能有**重叠关系**的数据类型进行相互转换的一种 TS 语法。`把其中一种该数据类型转换成另一种数据类型，类型断言和类型转换产生的效果一样，但语法格式不一样`

### 理解重叠关系：

1. **如果 A，B 是类，且有继承关系**

   [extends 关系]无论 A，B 谁是父类或子类，A 的对象变量可以断言成 B 类型，B 的对象变量可以断言成 A 类型。`一般情况下，把父类的类型断断言成子类 people as Stu;`

2. **如果 A，B 是类，但没有继承关系**

   两个类中所有 public 实例属性【不包括静态属性】加上所有的 public 实例方法完全相同或另一个类的子集，则这两个类可以相互断言，否则这两个类不能相互断言。

3. **如果 A 是类，B 是接口(`interface,type`)，并且 A 类实现了 B 接口[implement]**

   A 的对象变量可以断言成 B 接口类型，同样 B 接口类型的对象变量也可以断言成 A 类型

4. **如果 A 是类，B 是接口(`interface,type`)，并且 A 类没有实现了 B 接口**，断言关系与第二项相同

5. **如果 A 是一个函数上参数变量的联合类型**

   `string | number `,那么在函数内部可以断言成 string 或 number 类型

6. **多个类组合成联合类型如何断言？**

   `let vechile:Car | Bus | Trunk` vechile 可以断言成其中任意一种数据类型

7. **任何数据类型都可以转换成 any 或 unknown 类型**，any 或 unknown 类型也可以转换成任何其他数据类型

## 类型守卫

`定义：`在语句的块级作用域【if 语句内或条目运算符表达式内】缩小变量的一种类型推断的行为

### 1. 类型守卫准备：new 底层发生了什么？

      ```javascript
      // 1. 创建一个obj

      let obj = {};

      // 2. 让新创建的对象__proto__变量指向 Person 原型对象空间

      obj.__proto__ = Person.prototype;

      // 3. 借用 Person 构造函数中的为 obj 对象变量增加 age 属性和 phone 属性
      Person.apply(obj, ["1234", 23]);

      console.log(obj);
      ```

### 2. 类型判断方法

类型守卫可以帮助我们在块级作用域中获得更为需要的精确变量类型，从而减少不必要的类型断言。

1. 类型判断`typeof`

2. 属性或方法或函数判断`in`

3. 实例判断`instanceof`

4. 字面量相等判断`==, ===, !=, !==`

### 3. typeof 有何局限性？如何解决？

1. 作用：检测一个变量或一个对象的数据类型

2. 检测范围：string,number,undefined,null,symbol,bigint,boolean,object,function

3. 局限性: 检测不完全准确

   ```javascript

   typeof null === 'object'

   typeof [] === 'object'  期望得到 Array

   const set = new Set();
   typeof set === 'object'

   ```

4. 如何解决

   **`Object.prototype.toString.call`无法解决获取一个自定义的类的实例变量或构造函数的对象变量的真正创建类型，可以使用`instanceof`解决**

   ```javascript
   // 无法解决获取一个自定义的类的实例变量或构造函数的对象变量的真正创建类型，可以使用instanceof解决
   const set = new Set();
   const map = new Map();
   Object.prototype.toString.call([]); // [object Array]
   Object.prototype.toString.call(null); // [object null]
   Object.prototype.toString.call(set); // [object Set]
   Object.prototype.toString.call(map); // [object Map]
   ```

### 4. instanceof

1. 作用：判断一种自定义函数或类创建的对象变量的数据类型

2. `instanceof`执行后返回`true`的几种条件

   - `对象变量.__proto__` = `类名或函数名.prototype`

     解释：如果`instanceof`关键字 左边对象变量的 proto 属性指向的原型对象空间 = 右边类名或函数名的 prototype 对象指向的原型对象空间，那么返回 true

   - `对象变量.proto. ... .proto.__proto__` = `类名或函数名.prototype`
